/*
 * Medical Image Registration ToolKit (MIRTK)
 *
 * Copyright 2008-2015 Imperial College London
 * Copyright 2008-2013 Daniel Rueckert, Julia Schnabel
 * Copyright 2013-2015 Andreas Schuh
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef MIRTK_ImageTransformation_H
#define MIRTK_ImageTransformation_H

#include "mirtk/Transformation.h"
#include "mirtk/GenericImage.h"
#include "mirtk/InterpolateImageFunction.h"


namespace mirtk {


/** Image used to cache displacements
 *
 * \todo Use Vector3D<double> as voxel type to enable the caching of
 *       a 4D displacement field which is generated by a 4D transformation
 *       or a 3D SV FFD integrated over multiple time intervals.
 */
class ImageTransformationCache : public RealImage
{
  mirtkObjectMacro(ImageTransformationCache);
 
  /// Whether the cache requires an update
  mirtkPublicAttributeMacro(bool, Modified);

public:

  /// Constructor
  ImageTransformationCache() : _Modified(true) {}

  /// Constructor
  explicit ImageTransformationCache(const ImageAttributes &attr)
  :
    RealImage(attr, 3), _Modified(true)
  {}

  /// Destructor
  virtual ~ImageTransformationCache() {}
};


/**
 * Filter for image transformations.
 *
 * This class implements an image filter which takes an input image and a
 * transformation and computes the corresponding output image. The output
 * image is calculated by looping over the voxel locations and calculating
 * the corresponding voxel locations in the input image. The intensity of
 * the voxels of the output image is by interpolation from the input image.
 * Note, that the transformation is assumed to map the input image into the
 * output image and is therefore inverted during the execution of the filter.
 * All calculations are carried out using world coordinates rather than image
 * coordinates.
 */
class ImageTransformation : public Object
{
  mirtkObjectMacro(ImageTransformation);

  // ---------------------------------------------------------------------------
  // Attributes

  /// Untransformed input image
  mirtkPublicAggregateMacro(const BaseImage, Input);

  /// Transformed output image (grid)
  mirtkPublicAggregateMacro(BaseImage, Output);

  /// Image transformation
  mirtkReadOnlyAggregateMacro(const class Transformation, Transformation);

  /// Image interpolator
  mirtkPublicAggregateMacro(InterpolateImageFunction, Interpolator);

  /// Padding value in target (voxels in the target image with this
  /// value will be ignored)
  mirtkPublicAttributeMacro(double, TargetPaddingValue);

  /// Padding value in source (voxels outside the source image will
  /// be set to this value)
  mirtkPublicAttributeMacro(double, SourcePaddingValue);

  /// Scale factor for intensities in transformed image
  mirtkPublicAttributeMacro(double, ScaleFactor);

  /// Offset for intensities in transformed image
  mirtkPublicAttributeMacro(double, Offset);

  /// Temporal offset of input image (in addition to input _torigin)
  mirtkPublicAttributeMacro(double, InputTimeOffset);

  /// Temporal offset of output image (in addition to output _torigin)
  mirtkPublicAttributeMacro(double, OutputTimeOffset);

  /// Flag whether to invert transformation
  mirtkReadOnlyAttributeMacro(bool, Invert);

  /// Flag whether input is 2D
  mirtkPublicAttributeMacro(bool, TwoD);

  /// Cached displacements
  mirtkReadOnlyAggregateMacro(ImageTransformationCache, Cache);

  /// Whether the cache was allocated by this instance
  mirtkAttributeMacro(bool, CacheOwner);

  /// Interpolation mode to use for interpolating cached displacements
  mirtkPublicAttributeMacro(InterpolationMode, CacheInterpolation);

  /// Extrapolation mode to use when interpolating cached displacements
  mirtkPublicAttributeMacro(ExtrapolationMode, CacheExtrapolation);

  /// Interpolator for cached displacements
  mirtkComponentMacro(InterpolateImageFunction, DisplacementField);

  /// Number of points for which the required inverse transformation was invalid
  mirtkReadOnlyAttributeMacro(int, NumberOfSingularPoints);

  // ---------------------------------------------------------------------------
  // Custom setters
public:

  /// Set transformation
  virtual void Transformation(const class Transformation *);

  /// Set transformation cache
  virtual void Cache(ImageTransformationCache *);

  /// Enable/disable inversion of transformation
  virtual void Invert(bool);

  // ---------------------------------------------------------------------------
  // Construction/Destruction
public:

  /// Constructor
  ImageTransformation();

  /// Destructor
  virtual ~ImageTransformation();

  // ---------------------------------------------------------------------------
  // Execution

  /// Resample transformed input image on output image grid
  virtual void Run();

protected:

  /// Initialize filter
  virtual void Initialize();

};


} // namespace mirtk

#endif // MIRTK_ImageTransformation_H
