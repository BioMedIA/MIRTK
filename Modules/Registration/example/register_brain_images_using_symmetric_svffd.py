#!/usr/bin/env python

"""
Python script illustrating the use of a symmetric pairwise registration of two
brain scans using the SVFFD model based on the exponential map of a stationary
velocity field (SVF) represented as multi-variate cubic B-spline function.

For illustration, we use N4 bias corrected T1-weighted adult brain MR images of
the OASIS dataset for which manual annotations are provided by Neuromorphometrics Inc.
(see MICCAI 2012 Workshop on Multi-Atlas Labeling). These images are not included
and need to be obtained elsewhere. Alternatively, use other images available to you.

After the SVFFD algorithm is done, we transform each image by the half transformation
to illustrate how to obtain the flow of spatial mappings corresponding to the
one-parameter subgroup of diffeomorphic mappings generated by a SVF, i.e., exp(tv)
where exponent t corresponds to the length of the integration interval.
By default, the length of the integration interval for the full transformation from
target to source image is given by t=1.

When 'mirtk' Python module is not found, ensure to add the absolute path of the
lib/python directory of your MIRTK installation to the PYTHONPATH environment variable.
"""

import os
import mirtk

tgtuid = '1000'
srcuid = '1001'

imgdir = os.path.expanduser(os.path.join('~', 'Datasets', 'MAL35', 'N4'))
imgfmt = os.path.join(imgdir, '{id}.nii.gz')
tgtimg = imgfmt.format(id=tgtuid)
srcimg = imgfmt.format(id=srcuid)

affdof = 'aff.dof'
svffd  = 'svffd.dof.gz'
disp   = 'disp.nii.gz'
velo   = 'velo.nii.gz'
outfmt = '{id}-warped.nii.gz'
tgtout = outfmt.format(id=tgtuid)
srcout = outfmt.format(id=srcuid)

params = dict(sim='NMI', bins=64, bg=0, ds=5, be=.001)
energy = 'SIM[Image dissimilarity](I(1) o T^-0.5, I(2) o T^0.5) + BE[Bending energy](T)'
mffd   = 'None'  # required for inverse consistent/symmetric energy using SVFFD model


# affine pre-alignment
if not os.path.exists(affdof):
    print("\nPerform rigid and affine registration with 9 DOFs")
    if os.path.exists(svffd):  os.remove(svffd)
    # No shearing allowed to avoid warning with SVFFD registration using -dof_i option
    # instead of explicitly resampling the input source image in target image space.
    # The "register" command below may still display a warning because the inverse
    # homogeneous transformation matrix may be decomposed with small shearing values
    # due to numerical inaccuracies.
    mirtk.register(tgtimg, srcimg, '-par', 'Allow shearing', False,
                   model='Rigid+Affine', dofout=affdof, **params)

# compute SVFFD using symmetric energy function
if not os.path.exists(svffd):
    print("\nCompute SVFFD using symmetric energy function")
    if os.path.exists(tgtout): os.remove(tgtout)
    if os.path.exists(srcout): os.remove(srcout)
    if os.path.exists(disp): os.remove(disp)
    if os.path.exists(velo): os.remove(velo)
    # '-image' argument needed before srcimg because of use of '-dof_i'
    mirtk.register(tgtimg, '-image', srcimg, '-dof_i', affdof,
                   '-par', 'Energy function', energy,
                   '-par', 'Multi-level transformation', mffd,
                   model='SVFFD', dofin=affdof, dofout=svffd, **params)

# convert SVFFD to dense diplacement field saved as NIfTI image
if not os.path.exists(disp):
    print("\nConvert SVFFD to dense displacement field")
    mirtk.convert_dof(svffd, disp, output_format='disp')

# convert SVFFD to dense velocity field saved as NIfTI image
if not os.path.exists(velo):
    print("\nConvert SVFFD to dense velocity field")
    mirtk.convert_dof(svffd, velo, output_format='svf')

# apply SVFFD to transform each image half-way
if not os.path.exists(tgtout):
    print("\nTransforming target image using exp(-0.5 v)")
    mirtk.transform_image(tgtimg, tgtout, dofin=svffd, Tt=0, St=-0.5)
if not os.path.exists(srcout):
    print("\nTransforming source image using exp(+0.5 v)")
    mirtk.transform_image(srcimg, srcout, source_invdof=affdof, dofin=svffd, Tt=0, St=+0.5, target=tgtimg)

# evaluate similarity of transformed images
print("\nEvaluate similarity of transformed images:")
output = mirtk.evaluate_similarity(tgtout, srcout, '-noid', onexit='output')
print(output.replace(", ", "\n"))